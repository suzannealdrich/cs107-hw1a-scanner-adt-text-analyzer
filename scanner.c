#include "scanner.h"#include "stdlib.h"#include "assert.h"#include "string.h"struct ScannerImplementation {	FILE		*fp;				// input stream	char		*delimiters;		// set of possible delimeter characters	bool		discardDelimiters;	// eat delimeters if true; return them if false};Scanner NewScannerFromFile(FILE *fp, const char *delimiters, bool discardDelimiters){		Scanner		s;		if (fp == NULL) return NULL;		// allocate memory for scanner	s = malloc(sizeof(struct ScannerImplementation));	assert(s != NULL);	s->delimiters = malloc(strlen(delimiters));	assert(s->delimiters != NULL);	// initialize		s->fp = fp;	strcpy(s->delimiters, delimiters);	s->discardDelimiters = discardDelimiters;		return s;}Scanner NewScannerFromFilename(const char *filename, const char *delimiters, bool discardDelimiters){	return NewScannerFromFile(fopen(filename, "r"), delimiters, discardDelimiters);}void FreeScanner(Scanner s){	// free memory for scanner		if (s != NULL) {		if (s->delimiters != NULL) free(s->delimiters);		if (s->fp != NULL) fclose(s->fp);		free(s);	}}bool ReadNextToken(Scanner s, char buffer[], int bufLen){	int		tokenlength = 0;		// number of accumulated characters	int 	c;						// current character	bool 	isDelimiter;			// true if current character is a delimiter		if (s->discardDelimiters) SkipOver(s, s->delimiters);	// eat leading delimiters		// keep reading characters until buffer fills or EOF	while ((tokenlength + 1 < bufLen) && ((c = fgetc(s->fp)) != EOF)) {		isDelimiter = strchr(s->delimiters, c) != NULL;		if (isDelimiter && tokenlength > 0) {				// end of a token			ungetc(c, s->fp);								// push back delimiter			break;											// return token		}		buffer[tokenlength++] = c;							// append c to buffer		buffer[tokenlength] = '\0';							// terminate buffer		if (isDelimiter) break;								// return single delimeter token	}		return (tokenlength > 0);								// true if token found; false if EOF}int Skip(Scanner s, const char *set, bool skipMembers){	int		c;			// current character	bool	isMember;	// true if current character is a member of set	bool	doSkip;		// true if current character should be skipped	// keep reading characters until EOF	while ((c = fgetc(s->fp)) != EOF) {		isMember = strchr(set, c) != NULL;				// when skipMembers is true, skip members; otherwise, skip non-members				doSkip = (skipMembers ? isMember : !isMember);				if (doSkip == false) {			ungetc(c, s->fp);		// push back boundary character			break;					// done skipping		}	}		return c;						// return boundary character}int SkipOver(Scanner s, const char *skipSet){	return Skip(s, skipSet, true);		// skip characters occuring in skipSet}int SkipUntil(Scanner s, const char *untilSet){	return Skip(s, untilSet, false);	// skip characters not occuring in untilSet}